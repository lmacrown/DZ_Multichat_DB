getClass() : 해당 클래스의 함수를 가져옴
callback : 다른 코드의 인수로서 넘겨주는 실행 가능한 코드. 
Stream.filter() : 인자로 함수를 받으며 어떤 조건으로 Stream의 요소들을 필터링
Stream.map() : 인자로 함수를 받으며 Stream의 요소를 다른 형태로 변경
Stream.flatMap() : 평탄화라고 부르기도 하며 복잡한 자료 구조에 요소들을 단순한 자료구조로 변환
디자인 패턴 
GRASP : 각 객체에 책임을 부여하는 것으로 책임을 부여하는 원칙들을 말하는 패턴
1) information expert : 책임을 수행할 수 있는 데이터를 가지고 있는 객체에 책임을 부여
정보은닉을 통해 자신의 데이터를 감추고 오직 메소드로만 데이터를 처리하고 외부에는 기능(책임)만을 제공
2) Creator : 객체의 생성은 생성되는 객체의 컨텍스트를 알고 있는 다른 객체가 있다면 컨텍스트를 알고 있는 객체에 부여
3) Controller : 시스템 이벤트를 처리할 객체를 만듬
4) Low Coupling(결합도) : 객체들 간 또는 시스템들 간의 상호 의존도가 낮게 책임을 부여
5) High Cohesion(응집도) : 각 객체가 밀접하게 연관된 책임들만 가지도록 구성
6) Polymorphism(다형성) : 하나의 코드로 여러 자료형으로 구현되어 실행
7) Pure Fabrication(유연한 설계) : 기능적인 책임을 별도로 한 곳으로 관리하는 객체를 만듬. 
8) Indirection : 두 객체 사이의 직접적인 결합을 피하고자 다른 매개체를 통해 전달하는 것
9) Protected Variations : 안정된 인터페이스를 사용하여 변경에 대처
SOLID
1) SPR : 단일 책임 원칙. 한 클래스는 하나의 책임만 가짐
2) OCP : 개발-폐쇄 원칙. 확장에는 열려있으나 변경에는 닫혀 있어야 함. 다형성을 잘 활용
3) LSP : 리스코프 치환 원칙. 프로그램의 정확성을 깨면 안됨
4) ISP : 인터페이스 분리 원칙. 여러 개의 인터페이스가 하나의 인터페이스보다 낫다
5) DIP : 의존관계 역전 원칙. 구체화에 의존하지 않고 추상화에 의존해야 한다.
생성 패턴 :
구조 패턴 :
행위 패턴 :
chain 패턴 : 어떤 프로세스가 일어났을 떄 그 프로세스를 처리할 책임을 적당한 대상한테 넘겨줌
바이너리 파일 : 
리팩토링 : 결과의 변경없이 코드의 구조를 재조정

